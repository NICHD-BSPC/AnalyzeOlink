#' Export all test‐results for each contrast to a single Excel file
#'
#' @description
#'   For every contrast in \code{res_list} this function gathers the result
#'   tables for all test types listed in \code{names(res_list[[contrast]])} and writes them
#'   to one Excel workbook (one sheet per test type). Workbooks are saved to
#'   \code{outdir}.
#'
#' @param res_list Nested list of results: \code{res_list[[contrast]][[test]]}.
#' @param outdir   Directory path where Excel workbooks will be written.
#'
#' @return Invisibly, a named character vector giving the path of the workbook
#'   created for each contrast.
#' @export
export_stats_results <- function(res_list, outdir) {
  workbook_paths <- character()

  for (contrast in names(res_list)) {
    wb   <- openxlsx::createWorkbook()
    keep <- FALSE

    for (test_type in base::setdiff(names(res_list[[contrast]]), c("emm_int", "params"))) {
      df <- res_list[[contrast]][[test_type]]
      if (is.null(df) || nrow(df) == 0) next

      sheet_name <- get_test_name(test_type)
      df_fmt     <- format_results(df, drop_enrich_cols = FALSE, scientific_notation = FALSE)

      openxlsx::addWorksheet(wb, sheet_name)
      openxlsx::writeData(wb, sheet = sheet_name, x = df_fmt, withFilter = TRUE)
      keep <- TRUE
    }

    if (keep) {
      file_name <- paste0(contrast, "_results.xlsx")
      path      <- file.path(outdir, file_name)
      openxlsx::saveWorkbook(wb, path, overwrite = TRUE)
      workbook_paths[contrast] <- path
    }
  }

  return(workbook_paths)
}


#' Print statistical results by contrast and test type
#'
#' @description
#'   Creates a two-level tabset: first by contrast, then by test type.
#'   Each contrast tab links to the single Excel workbook generated by
#'   \code{export_stats_results()}.  Within every test-type tab an interactive
#'   datatable of the formatted results is displayed.
#'
#' @param res_list Nested list of contrasts of interest containing statistical
#'   results for all terms in the model.
#' @param res_list_1_effect Same as res_list but filtered for a single effect
#'   or term in the model.
#' @param outdir Directory path where Excel workbooks will be written.
#'
#' @return Invisibly returns \code{NULL}; generates Markdown + DT output.
#' @export
print_stats_results <- function(res_list,
                                res_list_1_effect,
                                outdir
) {
  # write workbooks once, then reuse the paths
  wb_paths <- export_stats_results(res_list, outdir)

  for (contrast in names(res_list_1_effect)) {
    mdcat(paste("###", contrast, "{.tabset}"))

    for (test_type in base::setdiff(names(res_list_1_effect[[contrast]]), c("emm_int","params"))) {
      test_header <- get_test_name(test_type)
      mdcat(paste("####", test_header))

      if (!is.na(wb_paths[contrast])) {
        mdcat(paste0("- [Download Excel workbook](", wb_paths[contrast], ")"))
      }

      df <- res_list_1_effect[[contrast]][[test_type]]
      df_fmt <- format_results(df, drop_enrich_cols = FALSE, scientific_notation = TRUE) %>%
          filter(df$Threshold == "Significant")
      if (nrow(df_fmt) == 0) {
        mdcat(sprintf("No significant results for contrast %s test %s", contrast, test_header))
        next
      }

      subchunkify(DT::datatable(df_fmt))
    }
  }
}


#' Export enrichment results to Excel workbooks
#'
#' @description
#'   Iterates over enrichment results for all contrasts, methods, test types,
#'   directions, and ontologies. Writes each result table to an Excel workbook
#'   with one sheet per ontology. Files are saved to
#'   \code{config$output_paths$functional_enrichment$results}.
#'
#' @param enrich_list Nested list of enrichment results with structure
#'   \code{contrast -> method -> test_type -> direction -> ontology -> data.frame}.
#' @param config Configuration list containing
#'   \code{output_paths$functional_enrichment$results}.
#'
#' @return Invisibly, a named character vector mapping
#'   \code{contrast_method_test_direction_ontology} to workbook paths.
#' @export
export_enrichment_results <- function(enrich_list, config) {
  requireNamespace("openxlsx")
  outdir   <- config$output_paths$functional_enrichment$results
  wb_paths <- character()

  for (contrast in names(enrich_list)) {
    for (method in names(enrich_list[[contrast]])) {
      test_list <- enrich_list[[contrast]][[method]]
      for (test_type in names(test_list)) {
        dir_list <- test_list[[test_type]]
        for (direction in names(dir_list)) {
          onto_list <- dir_list[[direction]]
          for (ontology in names(onto_list)) {
            df <- onto_list[[ontology]]
            if (is.null(df) || nrow(df) == 0) next

            # create workbook & sheet
            wb <- openxlsx::createWorkbook()
            sheet_name <- substr(
              paste(get_test_name(test_type), direction, ontology, sep = "_"),
              1, 31
            )
            df_fmt <- format_enrich_results(df, drop_enrich_cols = FALSE, scientific_notation = FALSE)

            openxlsx::addWorksheet(wb, sheet_name)
            openxlsx::writeData(wb, sheet = sheet_name, x = df_fmt, withFilter = TRUE)

            # save workbook
            fname <- paste(contrast, method, test_type, direction, ontology, "enrichment.xlsx", sep = "_")
            path  <- file.path(outdir, fname)
            openxlsx::saveWorkbook(wb, path, overwrite = TRUE)

            # record path
            key <- paste(contrast, method, test_type, direction, ontology, sep = "_")
            wb_paths[key] <- path
          }
        }
      }
    }
  }

  invisible(wb_paths)
}


#' Print enrichment results by contrast, method, and ontology
#'
#' @description
#'   Produces nested tabsets by contrast, method, test type, direction,
#'   and ontology. Each ontology tab shows a download link to the Excel
#'   workbook generated by \code{export_enrichment_results()} and prints
#'   an interactive datatable of significant enrichment results.
#'
#' @param enrich_list Nested list of enrichment results.
#' @param config Configuration list including \code{enrichment$methods}.
#'
#' @return Invisibly returns \code{NULL}; generates Markdown + DT output.
#' @export
print_enrichment_results <- function(enrich_list, config) {
  methods <- config$enrichment$methods
  if (is.null(methods) || length(methods) == 0) {
    mdcat("Set config -> enrichment -> methods.")
    return(invisible())
  }

  # export and get workbook paths
  wb_paths <- export_enrichment_results(enrich_list, config)

  for (contrast in names(enrich_list)) {
    mdcat(paste("###", contrast, "{.tabset}"))
    for (method in names(enrich_list[[contrast]])) {
      mdcat(paste("####", method, "{.tabset}"))
      test_list <- enrich_list[[contrast]][[method]]
      if (is.null(test_list)) {
        mdcat(paste("*No results for method", method, "in contrast", contrast, ".*"))
        next
      }
      for (test_type in names(test_list)) {
        test_header <- get_test_name(test_type)
        mdcat(paste("#####", test_header, "{.tabset}"))
        dir_list <- test_list[[test_type]]
        if (is.null(dir_list)) {
          mdcat(paste("*No results for", test_header, ".*"))
          next
        }
        for (direction in names(dir_list)) {
          mdcat(paste("######", direction, "{.tabset}"))
          onto_list <- dir_list[[direction]]
          if (is.null(onto_list)) {
            mdcat(paste("*No", direction, "results.*"))
            next
          }
          for (ontology in names(onto_list)) {
            mdcat(paste("#######", ontology))
            wb_key <- paste(contrast, method, test_type, direction, ontology, sep = "_")
            if (!(wb_key %in% names(wb_paths))) {
              mdcat(sprintf(
                "*No enrichment results for %s / %s / %s / %s / %s.*",
                contrast, method, test_header, direction, ontology
              ))
              next
            }
            mdcat(paste0("- [Download Excel workbook](", wb_paths[[wb_key]], ")"))

            df <- onto_list[[ontology]]
            if (is.null(df) || nrow(df) == 0) {
              mdcat(sprintf(
                "*No significant results for %s / %s / %s / %s / %s.*",
                contrast, method, test_header, direction, ontology
              ))
              next
            }
            df_fmt <- df %>%
              format_enrich_results(drop_enrich_cols = TRUE, scientific_notation = TRUE) %>%
              dplyr::filter(Threshold == "Significant")
            if (nrow(df_fmt) == 0) {
              mdcat(sprintf(
                "*No significant results for %s / %s / %s / %s / %s.*",
                contrast, method, test_header, direction, ontology
              ))
              next
            }
            subchunkify(DT::datatable(df_fmt))
          }
        }
      }
    }
  }

  invisible(NULL)
}


#' Print data from a SummarizedExperiment
#'
#' @description
#'   Extracts sample metadata, Olink data, and NPX counts from a
#'   \code{SummarizedExperiment} using \code{prep_data()}, writes them to an
#'   Excel file, prints metadata and a subset of the Olink data as datatables,
#'   and returns the data.
#'
#' @param se A \code{SummarizedExperiment} object.
#' @param config Configuration list with
#'   \code{output_paths$differential_expression$raw_data}.
#' @param show_first_n_rows Number of rows of Olink data to display.
#' @param print_tables Logical; if TRUE, print DT tables.
#' @param remove_coldata_from_olink Logical; if TRUE, remove colData columns from Olink data.
#'
#' @return Named list with components \code{metadata}, \code{olink_data}, and \code{counts}.
#' @export
print_data <- function(se, config, show_first_n_rows, print_tables = FALSE, remove_coldata_from_olink = FALSE) {
  data_list <- prep_data(se)

  # Export data to Excel and display the file link.
  path <- export_data(data_list, config)

  if (isFALSE(print_tables)) {
    # Display sample metadata.
    mdcat("#### NPX data & Sampletable")
    mdcat(paste0("- [Olink Data Excel File](", path, ")"))
  } else {
    mdcat("### Sampletable")
    mdcat(paste0("- [Olink Data Excel File](", path, ")"))
    subchunkify(DT::datatable(data_list$metadata))

    # Display Olink data.
    mdcat("### Olink data")
    mdcat(paste0("- [Olink Data Excel File](", path, ")"))
    if (isTRUE(remove_coldata_from_olink)) {
      # Remove metadata columns from olink_data to avoid redundancy
      cols_to_remove <- base::setdiff(colnames(data_list$metadata), "SampleID")
      olink_data_no_coldata <- data_list$olink_data %>% select(-all_of(cols_to_remove))
      subchunkify(DT::datatable(head(olink_data_no_coldata, n = show_first_n_rows)))
    } else {
      subchunkify(DT::datatable(head(data_list$olink_data, n = show_first_n_rows)))
    }
  }
  return(data_list)
}


#' Export data to Excel
#'
#' @description Writes sample metadata, Olink data, and NPX counts to an Excel file
#'   with each dataset on its own worksheet.
#'
#' @param data_list List from \code{prep_data()} containing
#'   \code{metadata}, \code{olink_data}, \code{counts}.
#' @param config Configuration list with
#'   \code{output_paths$differential_expression$raw_data}.
#'
#' @return File path of the saved Excel workbook.
#' @export
export_data <- function(data_list, config) {
  wb <- openxlsx::createWorkbook()

  for (name in names(data_list)) {
    openxlsx::addWorksheet(wb, name)
    openxlsx::writeData(wb, sheet = name, x = data_list[[name]], withFilter = TRUE)
  }

  path <- file.path(config, "data.xlsx")
  openxlsx::saveWorkbook(wb, path, overwrite = TRUE)
  return(path)
}


#' Export removed NPX rows
#'
#' @description
#'   Identifies rows in the original NPX data that were removed during
#'   outlier/QC filtering, and writes them to an Excel workbook.
#'
#' @param init_data Original NPX long-format data.
#' @param no_outlier_data NPX data after outlier/QC filtering.
#' @param directory Directory where the Excel workbook will be written.
#'
#' @return File path of the Excel workbook containing removed rows.
#' @export
export_removed_rows <- function(init_data,
                                no_outlier_data,
                                directory
) {

  path = file.path(directory, "removed_data.xlsx")
  wb <- openxlsx::createWorkbook()

  # build composite keys
  init_keyed <- init_data %>%
    dplyr::mutate(.key = paste(SampleID, Assay, Panel, sep = "||"))
  no_outlier_keyed <- no_outlier_data %>%
    dplyr::mutate(.key = paste(SampleID, Assay, Panel, sep = "||"))

  # find keys present initially but missing after filtering
  removed_keys <- base::setdiff(init_keyed$.key,
                          no_outlier_keyed$.key)

  # extract and clean up the removed rows
  removed_rows <- init_keyed %>%
    dplyr::filter(.key %in% removed_keys) %>%
    dplyr::select(-.key)

  # write to Excel
  name <- "removed_data"
  openxlsx::addWorksheet(wb, name)
  openxlsx::writeData(wb, sheet = name, x = removed_rows, withFilter = TRUE)
  openxlsx::saveWorkbook(wb, path, overwrite = TRUE)

  return(path)
}


#' Write Shapiro–Wilk normality test results to an Excel workbook
#'
#' @description
#'   Exports a named list of Shapiro–Wilk test result data frames to an Excel
#'   workbook, with each element written to its own worksheet.
#'
#' @param shapiro_results Named list of data.frames as returned by
#'   \code{\link{test_normality}}. Each must contain columns
#'   \code{protein}, \code{p.value}, and \code{p.adj}.
#' @param config Configuration list with
#'   \code{output_paths$differential_expression$qc}.
#'
#' @return Invisibly, the \code{openxlsx} workbook object.
#' @export
write_normality <- function(shapiro_results, config) {
  if (!is.list(shapiro_results) || is.null(names(shapiro_results))) {
    stop("`shapiro_results` must be a named list of data frames")
  }

  # Initialize a new workbook
  wb <- openxlsx::createWorkbook()

  # Add each Shapiro result as its own sheet
  for (sheet_name in names(shapiro_results)) {
    df <- shapiro_results[[sheet_name]]
    # Validate that df is a data.frame
    if (!inherits(df, "data.frame")) {
      warning(
        sprintf("Element '%s' is not a data.frame; skipping this sheet",
                sheet_name)
      )
      next
    }
    # Add worksheet and write data
    openxlsx::addWorksheet(wb, sheet_name)
    openxlsx::writeData(wb, sheet = sheet_name, x = df, withFilter = TRUE)
  }

  # Save the workbook to disk
  path <- file.path(config$output_paths$differential_expression$qc, paste0("shapiro_wilk.xlsx"))
  openxlsx::saveWorkbook(wb, file = path, overwrite = TRUE)
  mdcat("- [Shapiro-Wilk results](", path, ")")

  invisible(wb)
}
